# Communication Protocols of the Gandalf Workshop

This document outlines the standardized "paperwork" (data schemas) and communication protocols used between the Workshop Manager and the Specialist Artisans. These protocols ensure that every Commission is handled consistently, information flows efficiently, and all work is meticulously documented according to the Workshop's standards.

## 1. The Blueprint Schema (`blueprint.yaml`)

The "Blueprint" is the master plan created by a Planner Artisan (e.g., Software Architect, Lead Researcher) at the start of a Commission. It serves as the single source of truth for all subsequent work by Coder and Inspector Artisans. The Blueprint must be a YAML file (`blueprint.yaml`) and adhere to the following structure:

```yaml
# blueprint.yaml - Master Design Document for a Commission

commission_id: "unique_identifier_for_the_commission" # e.g., calc_gui_001, research_ai_ethics_002
commission_title: "Human-readable title of the commission"
commission_type: "software_mvp" | "research_report" # Specifies the nature of the final Product

# Section 1: Overview & Objectives
# Provided by the client, refined by the Planner Artisan
project_summary: |
  A concise description of the commission's goals and the Product to be created.
  What problem does it solve? Who is it for?
key_objectives:
  - "Objective 1..."
  _ - "Objective 2..."

# Section 2: Product Specifications (Metaphor: Detailed Technical Drawings)
# This section varies significantly based on commission_type

# Example for 'software_mvp'
product_specifications:
  type: "software"
  target_platform: "e.g., Desktop (Windows/macOS/Linux), Web, Mobile (iOS/Android)"
  primary_language_framework: "e.g., Python/Streamlit, JavaScript/React, Python/Django"
  modules:
    - module_name: "e.g., user_interface"
      description: "Handles the GUI and user interactions."
      components: # Or functions, classes, etc.
        - component_name: "e.g., main_window"
          description: "The primary application window."
          requirements:
            - "Must display input field."
            - "Must display buttons for numbers 0-9, operators (+, -, *, /), clear, and equals."
        - component_name: "e.g., calculation_logic"
          description: "Handles the arithmetic operations."
          requirements:
            - "Must correctly perform addition, subtraction, multiplication, division."
            - "Must handle division by zero gracefully."
  dependencies: # External libraries or services
    - "e.g., numpy"
    - "e.g., streamlit"
  unit_tests_required: # List of tests the Coder Artisan must ensure pass
    - "test_addition.py"
    - "test_division_by_zero.py"
  data_model: # If applicable
    # schema definitions

# Example for 'research_report'
product_specifications:
  type: "research"
  report_structure: # Outline of the report
    - section_title: "Introduction"
      key_questions_to_address:
        - "What is the scope of this research?"
        - "What are the main hypotheses?"
      required_subsections:
        - "Background"
        - "Problem Statement"
    - section_title: "Methodology"
      description: "How the research will be conducted."
      requirements:
        - "Detail data collection methods."
        - "Describe analytical approach."
    - section_title: "Findings for Hypothesis 1"
      # ... and so on for other sections and hypotheses
  key_sources_to_consult: # Optional initial list
    - "Source A (e.g., specific paper or database)"
  citation_style: "e.g., APA, MLA, IEEE"

# Section 3: Quality Standards & Acceptance Criteria
# Defines what a "well-crafted" Product looks like for this specific Commission
quality_criteria:
  - criterion: "All specified unit tests must pass." # For software
  - criterion: "Code must adhere to PEP8 standards (for Python)." # For software
  - criterion: "All claims must be supported by verifiable citations." # For research
  - criterion: "The Product must meet all functional requirements outlined in product_specifications."
  - criterion: "User interface must be intuitive and match descriptions." # For GUI software

# Section 4: Revision History (Metaphor: Blueprint Amendments)
# Automatically updated by the Workshop Manager after each significant revision cycle.
revisions:
  - version: "1.0"
    date: "YYYY-MM-DD"
    notes: "Initial Blueprint creation."
  # - version: "1.1"
  #   date: "YYYY-MM-DD"
  #   notes: "Revised module X based on early feedback."
```

## 2. The Quality Inspection Report Schema (`inspection_report.json`)

The "Quality Inspection Report" is generated by Inspector Artisans after they examine a version of the Product. It provides a quantitative measure of quality and a list of identified flaws. This report is crucial for the Workshop Manager to decide on the next steps (e.g., further revisions, final approval). It must be a JSON file and adhere to the following structure:

```json
{
  "commission_id": "unique_identifier_for_the_commission",
  "product_version_inspected": "e.g., v1, v2_revised_flaw_X",
  "inspection_date": "YYYY-MM-DDTHH:MM:SSZ",
  "lead_inspector_id": "identifier_of_the_primary_inspector_or_red_team_lead",
  "inspectors_involved": [
    "inspector_spec_compliance_id",
    "inspector_security_audit_id",
    "inspector_maintainability_id"
    // For research: "inspector_citation_validator_id", "inspector_source_reader_id", "inspector_skeptic_id"
  ],
  "quality_score": { // C(v) - Quantitative Quality Score
    "overall_score": 0.85, // Example: a value between 0.0 (low) and 1.0 (high), or other defined scale
    "metrics_details": [ // Breakdown of how the score was derived
      // For Software MVP
      { "metric_name": "passed_unit_tests", "value": 18, "max_value": 20, "weight": 0.4 },
      { "metric_name": "failed_unit_tests", "value": 2, "weight": -0.2 },
      { "metric_name": "linter_errors", "value": 5, "weight": -0.1 },
      { "metric_name": "spec_deviations_critical", "value": 0, "weight": -0.3 },
      { "metric_name": "spec_deviations_minor", "value": 1, "weight": -0.1 },
      // For Research Report
      // { "metric_name": "verified_claims", "value": 45, "weight": 0.5 },
      // { "metric_name": "unverified_claims", "value": 3, "weight": -0.2 },
      // { "metric_name": "contradicted_claims", "value": 1, "weight": -0.2 },
      // { "metric_name": "logical_fallacies_identified", "value": 1, "weight": -0.1 }
    ],
    "previous_score": 0.75 // Score of the prior version, if applicable
  },
  "identified_flaws": [ // List of issues discovered
    {
      "flaw_id": "unique_flaw_identifier_e.g., FLW001",
      "description": "Detailed description of the flaw.",
      "severity": "critical" | "high" | "medium" | "low" | "informational",
      "location_in_product": "e.g., module 'x', file 'y.py', line 'z' or section 'A', paragraph 'B'",
      "blueprint_requirement_violated": "ID or description of the Blueprint item not met",
      "suggested_remediation": "Optional: Inspector's suggestion for fixing the flaw",
      "status": "outstanding" | "addressed" | "deferred"
    }
    // ... more flaws
  ],
  "summary_assessment": "Overall qualitative assessment from the lead inspector. e.g., 'Significant improvements, but critical flaw X needs immediate attention.'",
  "recommendation": "approve_for_delivery" | "requires_revision" | "escalate_for_re_planning"
}
```

## 3. Workshop Manager-Artisan Interaction (Key Function Signatures)

The Workshop Manager (`workshop_manager.py` or `orchestrator.py`) directs the workflow by invoking Artisans (or crews of Artisans) for specific tasks. While the exact implementation will involve agent framework calls (CrewAI, AutoGen), these conceptual function signatures represent the core interactions:

```python
# Conceptual signatures within the Workshop Manager (Orchestrator)

class WorkshopManager:

    def commission_new_blueprint(self, user_prompt: str, commission_id: str) -> Path:
        """
        Assigns a new Commission to a Planner Artisan to create a Blueprint.
        Metaphor: "Manager gives client's request to the Head Draftsman."
        Args:
            user_prompt: The initial request from the client.
            commission_id: A unique ID for this new commission.
        Returns:
            Path to the generated blueprint.yaml file in the /blueprints directory.
        """
        pass

    def request_product_generation_or_revision(
        self,
        commission_id: str,
        blueprint_path: Path,
        current_product_path: Optional[Path] = None, # Path to current version if revising
        previous_inspection_report_path: Optional[Path] = None # To guide revisions
    ) -> Path:
        """
        Assigns a Coder Artisan (or team) to build or revise a Product based on the Blueprint.
        Metaphor: "Manager gives Blueprint to Master Craftsman for construction or rework."
        Args:
            commission_id: The ID of the commission.
            blueprint_path: Path to the relevant blueprint.yaml.
            current_product_path: Path to the existing product if this is a revision.
            previous_inspection_report_path: Path to the last inspection report detailing flaws.
        Returns:
            Path to the newly generated or revised product version in /commissions_in_progress.
        """
        pass

    def initiate_quality_inspection(
        self,
        commission_id: str,
        product_to_inspect_path: Path,
        blueprint_path: Path
    ) -> Path:
        """
        Assigns an Inspector Artisan (or Red Team) to conduct a Quality Inspection on a Product.
        Metaphor: "Manager sends a finished piece to the Quality Control Guild for assessment."
        Args:
            commission_id: The ID of the commission.
            product_to_inspect_path: Path to the product version to be inspected.
            blueprint_path: Path to the blueprint for compliance checking.
        Returns:
            Path to the generated inspection_report.json in the /quality_control_lab.
        """
        pass

    def finalize_commission_and_deliver(
        self,
        commission_id: str,
        final_product_path: Path,
        final_inspection_report_path: Path
    ) -> None:
        """
        Packages the final Product and its Inspection Report for delivery (e.g., to /completed_commissions).
        Metaphor: "Manager approves the final Product, archives records, and prepares it for the client."
        Args:
            commission_id: The ID of the commission.
            final_product_path: Path to the approved final product.
            final_inspection_report_path: Path to the final inspection report.
        """
        pass

    def request_blueprint_revision(
        self,
        commission_id: str,
        original_blueprint_path: Path,
        failure_history: dict # Contains C(v) history, unresolved flaws
    ) -> Path:
        """
        When a Commission is failing due to fundamental design issues, sends it back to a Planner Artisan
        to revise the original Blueprint. (Corresponds to Tier 2 Regression Protocol Re-Plan).
        Metaphor: "Manager sends a flawed design back to the Design Studio with notes on what went wrong."
        Args:
            commission_id: The ID of the commission.
            original_blueprint_path: Path to the blueprint that needs revision.
            failure_history: Data about why the current blueprint is failing.
        Returns:
            Path to the revised blueprint.yaml.
        """
        pass

# Note: Actual implementation will use CrewAI/AutoGen agent execution calls
# within these conceptual methods. For example, `commission_new_blueprint` might
# initialize and run a CrewAI "Planner Crew".
```

These standardized communication protocols are the bedrock of the Gandalf Workshop's efficiency and quality assurance, ensuring every Artisan understands their role and every Commission is managed with precision.
