# Makefile for the Gandalf Trust Framework

# Ensure that PROMPT is set, but allow it to be overridden from the command line
PROMPT ?= a simple CLI tool that takes a name and prints a greeting
AUDIT_APP_NAME ?= app

# Default target
.PHONY: default
default: develop

# Target to install dependencies using uv and the lockfile
.PHONY: install
install:
	@echo "--- Ensuring virtual environment exists and installing dependencies ---"
	@if [ ! -d ".venv" ]; then \
		echo "Creating virtual environment using uv..."; \
		uv venv; \
	fi
	uv pip sync requirements.txt --python .venv/bin/python
	@echo "✅ Virtual environment ready and dependencies installed."

# Target to compile requirements.in to requirements.txt (lock the dependencies)
.PHONY: lock
lock:
	@echo "--- Compiling requirements.in to requirements.txt using uv ---"
	uv pip compile requirements.in -o requirements.txt
	@echo "✅ Lockfile requirements.txt generated."

# Target for the main development workflow
.PHONY: develop
develop: install
	@echo "--- Starting development workflow for prompt: $(PROMPT) ---"
	@echo "--- [DEV] Performing BDD-aware placeholder code generation and scaffolding ---"
	# Ensure base directories exist
	mkdir -p gandalf_workshop
	mkdir -p gandalf_workshop/tests
	mkdir -p gandalf_workshop/tests/features
	mkdir -p gandalf_workshop/tests/step_definitions

	# Create __init__.py files to ensure modules are recognized
	touch gandalf_workshop/__init__.py
	touch gandalf_workshop/tests/__init__.py
	touch gandalf_workshop/tests/step_definitions/__init__.py

	# 1. Generate Placeholder Application Code
	@echo "Creating placeholder application file: gandalf_workshop/$(PROMPT).py"
	@echo "# Placeholder application code for $(PROMPT)\n\
def main():\n\
    print(\"Hello from $(PROMPT)!\")\n\
    return \"Hello from $(PROMPT)!\" # Return a value for easier testing\n\
\n\
# The AI will add more complex structure later, including if __name__ == '__main__'\n\
# For placeholder, main() contains all logic for full coverage by unit test." > "gandalf_workshop/$(PROMPT).py"

	# 2. Generate Placeholder Unit Test
	@echo "Creating placeholder unit test file: gandalf_workshop/tests/test_$(PROMPT).py"
	@echo "# Placeholder unit tests for $(PROMPT)\n\
from gandalf_workshop.$(PROMPT) import main as feature_main\n\
\n\
def test_feature_main_runs_and_returns_expected_message():\n\
    # Call the main function from the scaffolded feature to get coverage\n\
    expected_message = \"Hello from $(PROMPT)!\"\n\
    try:\n\
        result = feature_main()\n\
        assert result == expected_message, f\"Expected '{expected_message}', got '{result}'\"\n\
    except Exception as e:\n\
        assert False, f\"feature_main() raised an exception: {e}\"\n\
\n\
def test_another_placeholder():\n\
    # Add more unit tests as needed for initial coverage\n\
    x = 10\n\
    y = 20\n\
    assert x + y == 30, \"Basic arithmetic check\"" > "gandalf_workshop/tests/test_$(PROMPT).py"

	# 3. Generate Placeholder BDD Feature File
	@echo "Creating placeholder BDD feature file: gandalf_workshop/tests/features/$(PROMPT).feature"
	@echo "Feature: $(PROMPT) basic functionality\n\
  As a user\n\
  I want to use the $(PROMPT) feature\n\
  So that I can achieve a placeholder goal.\n\
\n\
  Scenario: Basic invocation of $(PROMPT)\n\
    Given the $(PROMPT) feature is set up\n\
    When I execute the $(PROMPT) feature\n\
    Then I should see a success message" > "gandalf_workshop/tests/features/$(PROMPT).feature"

	# 4. Generate Placeholder BDD Step Definition File
	@echo "Creating placeholder BDD step definition file: gandalf_workshop/tests/step_definitions/test_$(PROMPT)_steps.py"
	@echo "# Step definitions for $(PROMPT).feature\n\
from pytest_bdd import scenarios, given, when, then # Removed unused parsers\n\
# import any necessary modules from your application code, e.g.:\n\
# from gandalf_workshop.$(PROMPT) import main as feature_main\n\
\n\
# Load scenarios from the feature file\n\
scenarios('../features/$(PROMPT).feature')\n\
\n\
@given('the $(PROMPT) feature is set up')\n\
def feature_setup():\n\
    # Placeholder: any setup required before executing the feature\n\
    print(\"Setting up $(PROMPT) feature\")\n\
    pass\n\
\n\
@when('I execute the $(PROMPT) feature')\n\
def execute_feature():\n\
    # Placeholder: simulate execution of the feature\n\
    # Example: feature_main()\n\
    print(\"Executing $(PROMPT) feature\")\n\
    pass\n\
\n\
@then('I should see a success message')\n\
def success_message():\n\
    # Placeholder: assert the expected outcome\n\
    print(\"$(PROMPT) success (placeholder)\")\n\
    assert True, \"OK\" # Shortened assertion message\n" > "gandalf_workshop/tests/step_definitions/test_$(PROMPT)_steps.py"

	# Keep existing necessary scaffold files if they are still relevant
	mkdir -p gandalf_workshop/blueprints
	mkdir -p gandalf_workshop/artisan_guildhall/inspectors
	mkdir -p gandalf_workshop/specs
	touch main.py # This might be generated by the AI later, or be a generic entry point
	@echo "# Main entry point for the application.\n\
# For $(PROMPT), see gandalf_workshop/$(PROMPT).py" > main.py
	touch gandalf_workshop/specs/data_models.py
	@echo "# Data models for Gandalf Workshop.\n\
# Specific models for $(PROMPT) may be defined by AI agents." > gandalf_workshop/specs/data_models.py
	# These manager files are core to the framework, not feature-specific, so keep them.
	# If they don't exist, copy them. Otherwise, leave them.
	@if [ ! -f gandalf_workshop/workshop_manager.py ]; then \
		cp auditing/scaffold_templates/workshop_manager.template.py gandalf_workshop/workshop_manager.py; \
	fi
	@if [ ! -f gandalf_workshop/tests/test_workshop_manager.py ]; then \
		cp auditing/scaffold_templates/test_workshop_manager.template.py gandalf_workshop/tests/test_workshop_manager.py; \
	fi

	@echo "✅ BDD-aware placeholder code and scaffold generated for $(PROMPT)."

	@echo "--- [DEV] Running full audit pipeline ---"
	auditing/run_full_audit.sh

	@echo "--- [DEV] Audit successful, preparing commit ---"
	# Add the specific files generated for the new feature $(PROMPT)
	git add "gandalf_workshop/$(PROMPT).py" \
		"gandalf_workshop/tests/test_$(PROMPT).py" \
		"gandalf_workshop/tests/features/$(PROMPT).feature" \
		"gandalf_workshop/tests/step_definitions/test_$(PROMPT)_steps.py"
	# Add the audit receipt
	git add auditing/LATEST_AUDIT_RECEIPT.md
	# Add any __init__.py files that might have been created or modified (e.g. if new dirs)
	# This will also catch existing __init__.py files if they were modified, which is fine.
	git add gandalf_workshop/__init__.py \
		gandalf_workshop/tests/__init__.py \
		gandalf_workshop/tests/step_definitions/__init__.py
	# Add other potentially modified framework files that are part of the basic scaffold.
	# These are less likely to change with every PROMPT but are part of the core files touched by scaffold.
	git add main.py \
		gandalf_workshop/specs/data_models.py \
		gandalf_workshop/workshop_manager.py \
		gandalf_workshop/tests/test_workshop_manager.py
	# Note: gandalf_workshop/blueprints/ and gandalf_workshop/artisan_guildhall/inspectors/
	# are directories. If files are added there by future AI steps, they would need specific handling
	# or a broader `git add gandalf_workshop/blueprints/*` if that's intended.
	# For now, the scaffold doesn't add specific files into these blueprint/inspector dirs.
	git commit -m "feat: Scaffold $(PROMPT) with BDD tests and pass audit" -m "Generated scaffold for $(PROMPT):\n- Application code\n- Unit tests\n- BDD feature file\n- BDD step definitions\n\nAudit passed and LATEST_AUDIT_RECEIPT.md included."
	@echo "✅ Feature $(PROMPT) and audit receipt committed."

# Target to run the full audit pipeline directly
.PHONY: audit
audit:
	@echo "--- Running full audit pipeline ---"
	auditing/run_full_audit.sh
	@echo "✅ Audit pipeline finished."

# Target to clean up generated files
.PHONY: clean
clean:
	@echo "--- Cleaning up generated files ---"
	rm -f gandalf_workshop/*.py
	rm -f auditing/LATEST_AUDIT_RECEIPT.md
	rm -rf gandalf_workshop/__pycache__
	rm -rf gandalf_workshop/tests/__pycache__
	rm -f gandalf_workshop/tests/test_dummy.py
	rm -f .coverage
	@echo "✅ Cleanup complete."
